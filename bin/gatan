#!/usr/bin/env bash

set -euo pipefail

SCRIPT_PATH="${BASH_SOURCE[0]}"
SCRIPT_DIR="${SCRIPT_PATH%/*}"
if [ "$SCRIPT_DIR" = "$SCRIPT_PATH" ]; then
  SCRIPT_DIR="."
fi
SCRIPT_DIR="$(cd "$SCRIPT_DIR" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# shellcheck source=lib/gatan/constants.sh
. "$PROJECT_ROOT/lib/gatan/constants.sh"
# shellcheck source=lib/gatan/core.sh
. "$PROJECT_ROOT/lib/gatan/core.sh"
# shellcheck source=lib/gatan/actions.sh
. "$PROJECT_ROOT/lib/gatan/actions.sh"
# shellcheck source=lib/gatan/ui.sh
. "$PROJECT_ROOT/lib/gatan/ui.sh"

APP_VERSION="$(gatan_version)"
APP_ROWS=()
APP_SELECTED_INDEX=0
APP_SCROLL_INDEX=0
APP_STATUS_MESSAGE="Ready."
APP_STATUS_EXPIRES_AT=0
APP_INSPECT_PID=""
APP_INSPECT_COMMAND=""
APP_INSPECT_CONTENT=""
APP_INSPECT_STATIC_CONTENT=""
APP_INSPECT_TOP_CONTENT=""
APP_INSPECT_TOP_NEXT_AT=0
APP_INSPECT_TOP_JOB_PID=""
APP_INSPECT_TOP_JOB_FILE=""
APP_MAIN_REFRESH_NEXT_AT=0
APP_MAIN_REFRESH_JOB_PID=""
APP_MAIN_REFRESH_JOB_FILE=""
APP_MAIN_REFRESH_NOTIFY_ON_COMPLETE=0
APP_VIEW="main"
APP_RUNNING=1
APP_NEEDS_REDRAW=0
SUDO_KEEPALIVE_PID=""

app_mark_redraw() {
  APP_NEEDS_REDRAW=1
}

app_print_help() {
  cat <<'EOF_HELP'
Usage: gatan [--help] [--version]

Inspect TCP listening processes in a full-screen terminal UI.

Options:
  --help       Show this help message
  --version    Show version
EOF_HELP
}

app_set_status() {
  local message="$1"
  local ttl="${2:-$GATAN_STATUS_TTL_SECONDS}"
  local now_ms

  now_ms="$(app_now_millis)"
  APP_STATUS_MESSAGE="$message"
  APP_STATUS_EXPIRES_AT=$((now_ms + (ttl * 1000)))
  app_mark_redraw
}

app_get_status_message() {
  printf '%s\n' "$APP_STATUS_MESSAGE"
}

app_expire_status_if_needed() {
  local now_ms="${1:-}"

  if [ -z "$now_ms" ]; then
    now_ms="$(app_now_millis)"
  fi

  if [ "$APP_STATUS_EXPIRES_AT" -gt 0 ] && [ "$now_ms" -ge "$APP_STATUS_EXPIRES_AT" ]; then
    APP_STATUS_MESSAGE="Ready."
    APP_STATUS_EXPIRES_AT=0
    return 0
  fi

  return 1
}

app_input_timeout_seconds() {
  # Input polling runs on a fixed non-blocking cadence in app_run.
  printf '0\n'
}

app_now_millis() {
  local now_real
  local seconds
  local fraction

  if [ -n "${EPOCHREALTIME:-}" ]; then
    now_real="$EPOCHREALTIME"
    seconds="${now_real%.*}"
    fraction="${now_real#*.}"
    fraction="${fraction//[^0-9]/}"
    fraction="${fraction}000"
    fraction="${fraction:0:3}"
    printf '%s\n' "$((10#$seconds * 1000 + 10#$fraction))"
    return 0
  fi

  printf '%s000\n' "$(date +%s)"
}

app_start_sudo_keepalive() {
  (
    while true; do
      sleep "$GATAN_SUDO_KEEPALIVE_INTERVAL"
      sudo -n true >/dev/null 2>&1 || exit 0
    done
  ) &
  SUDO_KEEPALIVE_PID=$!
}

app_stop_sudo_keepalive() {
  if [ -n "$SUDO_KEEPALIVE_PID" ]; then
    kill "$SUDO_KEEPALIVE_PID" >/dev/null 2>&1 || true
    wait "$SUDO_KEEPALIVE_PID" >/dev/null 2>&1 || true
    SUDO_KEEPALIVE_PID=""
  fi
}

app_stop_inspect_top_refresh() {
  if [ -n "$APP_INSPECT_TOP_JOB_PID" ]; then
    kill "$APP_INSPECT_TOP_JOB_PID" >/dev/null 2>&1 || true
    wait "$APP_INSPECT_TOP_JOB_PID" >/dev/null 2>&1 || true
    APP_INSPECT_TOP_JOB_PID=""
  fi

  if [ -n "$APP_INSPECT_TOP_JOB_FILE" ] && [ -f "$APP_INSPECT_TOP_JOB_FILE" ]; then
    rm -f "$APP_INSPECT_TOP_JOB_FILE" >/dev/null 2>&1 || true
  fi

  APP_INSPECT_TOP_JOB_FILE=""
  APP_INSPECT_TOP_NEXT_AT=0
}

app_stop_main_refresh() {
  if [ -n "$APP_MAIN_REFRESH_JOB_PID" ]; then
    kill "$APP_MAIN_REFRESH_JOB_PID" >/dev/null 2>&1 || true
    wait "$APP_MAIN_REFRESH_JOB_PID" >/dev/null 2>&1 || true
    APP_MAIN_REFRESH_JOB_PID=""
  fi

  if [ -n "$APP_MAIN_REFRESH_JOB_FILE" ] && [ -f "$APP_MAIN_REFRESH_JOB_FILE" ]; then
    rm -f "$APP_MAIN_REFRESH_JOB_FILE" >/dev/null 2>&1 || true
  fi

  APP_MAIN_REFRESH_JOB_FILE=""
  APP_MAIN_REFRESH_NEXT_AT=0
  APP_MAIN_REFRESH_NOTIFY_ON_COMPLETE=0
}

app_cleanup() {
  app_stop_main_refresh
  app_stop_inspect_top_refresh
  app_stop_sudo_keepalive
  ui_restore_terminal
}

app_refresh_rows() {
  local tmp_file

  tmp_file="$(mktemp "${TMPDIR:-/tmp}/gatan-main-refresh.XXXXXX")" || return 1
  if ! core_collect_sorted_listeners >"$tmp_file" 2>/dev/null; then
    rm -f "$tmp_file" >/dev/null 2>&1 || true
    return 1
  fi

  app_apply_rows_from_file "$tmp_file" || true
  rm -f "$tmp_file" >/dev/null 2>&1 || true
  return 0
}

app_row_pid() {
  local row="$1"
  local pid

  IFS=$'\t' read -r _ pid _ <<EOF_ROW
$row
EOF_ROW
  printf '%s\n' "${pid:-}"
}

app_row_command() {
  local row="$1"
  local command

  IFS=$'\t' read -r command _ <<EOF_ROW
$row
EOF_ROW
  printf '%s\n' "${command:-}"
}

app_apply_rows_from_file() {
  local file="$1"
  local row
  local prev_selected_pid=""
  local new_selected_index=-1
  local changed=0
  local i
  local candidate_pid
  local new_rows=()

  if [ "${#APP_ROWS[@]}" -gt 0 ] && [ "$APP_SELECTED_INDEX" -ge 0 ] && [ "$APP_SELECTED_INDEX" -lt "${#APP_ROWS[@]}" ]; then
    prev_selected_pid="$(app_row_pid "${APP_ROWS[$APP_SELECTED_INDEX]}")"
  fi

  while IFS= read -r row; do
    if [ -n "$row" ]; then
      new_rows+=("$row")
    fi
  done <"$file"

  if [ "${#APP_ROWS[@]}" -ne "${#new_rows[@]}" ]; then
    changed=1
  else
    for ((i = 0; i < ${#new_rows[@]}; i++)); do
      if [ "${APP_ROWS[$i]}" != "${new_rows[$i]}" ]; then
        changed=1
        break
      fi
    done
  fi

  if [ "$changed" -eq 0 ]; then
    return 1
  fi

  APP_ROWS=("${new_rows[@]}")

  if [ "${#APP_ROWS[@]}" -eq 0 ]; then
    APP_SELECTED_INDEX=0
    APP_SCROLL_INDEX=0
    app_mark_redraw
    return 0
  fi

  if [ -n "$prev_selected_pid" ]; then
    for ((i = 0; i < ${#APP_ROWS[@]}; i++)); do
      candidate_pid="$(app_row_pid "${APP_ROWS[$i]}")"
      if [ "$candidate_pid" = "$prev_selected_pid" ]; then
        new_selected_index="$i"
        break
      fi
    done
  fi

  if [ "$new_selected_index" -ge 0 ]; then
    APP_SELECTED_INDEX="$new_selected_index"
  elif [ "$APP_SELECTED_INDEX" -ge "${#APP_ROWS[@]}" ]; then
    APP_SELECTED_INDEX=$((${#APP_ROWS[@]} - 1))
  elif [ "$APP_SELECTED_INDEX" -lt 0 ]; then
    APP_SELECTED_INDEX=0
  fi

  app_mark_redraw
  return 0
}

app_start_main_refresh() {
  if [ -n "$APP_MAIN_REFRESH_JOB_PID" ] && kill -0 "$APP_MAIN_REFRESH_JOB_PID" >/dev/null 2>&1; then
    return 1
  fi

  if [ -n "$APP_MAIN_REFRESH_JOB_FILE" ] && [ -f "$APP_MAIN_REFRESH_JOB_FILE" ]; then
    rm -f "$APP_MAIN_REFRESH_JOB_FILE" >/dev/null 2>&1 || true
  fi

  APP_MAIN_REFRESH_JOB_FILE="$(mktemp "${TMPDIR:-/tmp}/gatan-main-refresh.XXXXXX")" || return 1
  (
    core_collect_sorted_listeners >"$APP_MAIN_REFRESH_JOB_FILE" 2>/dev/null || true
  ) &
  APP_MAIN_REFRESH_JOB_PID=$!
  return 0
}

app_request_main_refresh() {
  local notify_on_complete="${1:-0}"

  if [ "$notify_on_complete" -eq 1 ]; then
    APP_MAIN_REFRESH_NOTIFY_ON_COMPLETE=1
  fi

  APP_MAIN_REFRESH_NEXT_AT=0
  app_start_main_refresh || true
  return 0
}

app_poll_main_refresh() {
  local now_ms="$1"

  if [ -z "$APP_MAIN_REFRESH_JOB_PID" ]; then
    return 1
  fi

  if kill -0 "$APP_MAIN_REFRESH_JOB_PID" >/dev/null 2>&1; then
    return 1
  fi

  wait "$APP_MAIN_REFRESH_JOB_PID" >/dev/null 2>&1 || true
  APP_MAIN_REFRESH_JOB_PID=""

  if [ -n "$APP_MAIN_REFRESH_JOB_FILE" ] && [ -f "$APP_MAIN_REFRESH_JOB_FILE" ]; then
    app_apply_rows_from_file "$APP_MAIN_REFRESH_JOB_FILE" || true
    rm -f "$APP_MAIN_REFRESH_JOB_FILE" >/dev/null 2>&1 || true
  fi
  APP_MAIN_REFRESH_JOB_FILE=""
  APP_MAIN_REFRESH_NEXT_AT=$((now_ms + GATAN_MAIN_REFRESH_INTERVAL_MS))

  if [ "$APP_MAIN_REFRESH_NOTIFY_ON_COMPLETE" -eq 1 ]; then
    APP_MAIN_REFRESH_NOTIFY_ON_COMPLETE=0
    app_set_status "Refreshed listener list."
  fi

  return 0
}

app_tick_main_refresh() {
  local now_ms="$1"

  app_poll_main_refresh "$now_ms" || true

  if [ -n "$APP_MAIN_REFRESH_JOB_PID" ]; then
    return 0
  fi

  if [ "$APP_MAIN_REFRESH_NEXT_AT" -gt "$now_ms" ]; then
    return 0
  fi

  app_start_main_refresh || true
  APP_MAIN_REFRESH_NEXT_AT=$((now_ms + GATAN_MAIN_REFRESH_INTERVAL_MS))
  return 0
}

app_selected_row() {
  if [ "${#APP_ROWS[@]}" -eq 0 ]; then
    return 1
  fi

  printf '%s\n' "${APP_ROWS[$APP_SELECTED_INDEX]}"
}

app_selected_pid() {
  local row

  row="$(app_selected_row)" || return 1
  app_row_pid "$row"
}

app_selected_command() {
  local row

  row="$(app_selected_row)" || return 1
  app_row_command "$row"
}

app_table_height() {
  local term_rows
  local term_cols
  local table_rows
  local frame_overhead

  ui_get_terminal_size_into term_rows term_cols
  frame_overhead="${GATAN_MAIN_FRAME_OVERHEAD:-6}"
  if [ "$term_rows" -ge $((frame_overhead + 1)) ]; then
    frame_overhead=$((frame_overhead + 1))
  fi

  table_rows=$((term_rows - frame_overhead))
  if [ "$table_rows" -lt 1 ]; then
    table_rows=1
  fi

  printf '%s\n' "$table_rows"
}

app_adjust_scroll() {
  local table_rows

  table_rows="$(app_table_height)"

  if [ "$APP_SELECTED_INDEX" -lt "$APP_SCROLL_INDEX" ]; then
    APP_SCROLL_INDEX="$APP_SELECTED_INDEX"
  fi

  if [ "$APP_SELECTED_INDEX" -ge $((APP_SCROLL_INDEX + table_rows)) ]; then
    APP_SCROLL_INDEX=$((APP_SELECTED_INDEX - table_rows + 1))
  fi

  if [ "$APP_SCROLL_INDEX" -lt 0 ]; then
    APP_SCROLL_INDEX=0
  fi
}

app_compose_inspect_content() {
  local metrics_snapshot="${1:-}"
  local mode="${2:-ready}"
  local line
  local key
  local value
  local in_attrs=1
  local open_files_block=""
  local info_pid=""
  local info_ppid=""
  local info_user=""
  local info_command=""
  local info_cwd=""
  local live_pid=""
  local live_ppid=""
  local live_user=""
  local live_command=""
  local live_cpu=""
  local live_mem=""
  local live_rss=""
  local live_vsz=""
  local live_elapsed=""
  local live_state=""
  local placeholder="(loading...)"
  local out_pid
  local out_ppid
  local out_user
  local out_command
  local out_cwd
  local out_cpu
  local out_mem
  local out_rss
  local out_vsz
  local out_elapsed
  local out_state

  if [ "$mode" = "unavailable" ]; then
    placeholder="(unavailable)"
  fi

  while IFS= read -r line; do
    if [ "$in_attrs" -eq 1 ]; then
      if [ -z "$line" ]; then
        in_attrs=0
        continue
      fi

      key="${line%%[[:space:]]*}"
      value="${line#"$key"}"
      value="${value#"${value%%[![:space:]]*}"}"
      case "$key" in
        PID) info_pid="$value" ;;
        PPID) info_ppid="$value" ;;
        USER) info_user="$value" ;;
        COMMAND) info_command="$value" ;;
        CWD) info_cwd="$value" ;;
      esac
      continue
    fi

    if [ -n "$open_files_block" ]; then
      open_files_block="${open_files_block}"$'\n'"$line"
    else
      open_files_block="$line"
    fi
  done <<EOF_STATIC
$APP_INSPECT_STATIC_CONTENT
EOF_STATIC

  if [ -n "$metrics_snapshot" ] && [ "$metrics_snapshot" != "(metrics unavailable)" ]; then
    while IFS= read -r line; do
      [ -z "$line" ] && continue
      key="${line%%[[:space:]]*}"
      value="${line#"$key"}"
      value="${value#"${value%%[![:space:]]*}"}"
      case "$key" in
        PID) live_pid="$value" ;;
        PPID) live_ppid="$value" ;;
        USER) live_user="$value" ;;
        COMMAND) live_command="$value" ;;
        CPU) live_cpu="$value" ;;
        MEM) live_mem="$value" ;;
        RSS) live_rss="$value" ;;
        VSZ) live_vsz="$value" ;;
        ELAPSED) live_elapsed="$value" ;;
        STATE) live_state="$value" ;;
      esac
    done <<EOF_METRICS
$metrics_snapshot
EOF_METRICS
  fi

  out_pid="${live_pid:-${info_pid:--}}"
  out_ppid="${live_ppid:-${info_ppid:--}}"
  out_user="${live_user:-${info_user:--}}"
  out_command="${live_command:-${info_command:--}}"
  out_cwd="${info_cwd:--}"
  out_cpu="${live_cpu:-$placeholder}"
  out_mem="${live_mem:-$placeholder}"
  out_rss="${live_rss:-$placeholder}"
  out_vsz="${live_vsz:-$placeholder}"
  out_elapsed="${live_elapsed:-$placeholder}"
  out_state="${live_state:-$placeholder}"

  printf '%-8s %s\n' "PID" "$out_pid"
  printf '%-8s %s\n' "PPID" "$out_ppid"
  printf '%-8s %s\n' "USER" "$out_user"
  printf '%-8s %s\n' "COMMAND" "$out_command"
  printf '%-8s %s\n' "CWD" "$out_cwd"
  printf '%-8s %s\n' "CPU" "$out_cpu"
  printf '%-8s %s\n' "MEM" "$out_mem"
  printf '%-8s %s\n' "RSS" "$out_rss"
  printf '%-8s %s\n' "VSZ" "$out_vsz"
  printf '%-8s %s\n' "ELAPSED" "$out_elapsed"
  printf '%-8s %s\n' "STATE" "$out_state"
  printf '\n'

  if [ -n "$open_files_block" ]; then
    printf '%s\n' "$open_files_block"
  else
    printf 'Open files (first %s):\n' "$GATAN_OPEN_FILES_LIMIT"
    printf '%s\n' "(no open files data)"
  fi
}

app_load_inspect() {
  local pid="$1"

  app_stop_inspect_top_refresh

  APP_INSPECT_STATIC_CONTENT="$(actions_inspect_static "$pid" 2>/dev/null || true)"
  if [ -z "$APP_INSPECT_STATIC_CONTENT" ]; then
    APP_INSPECT_CONTENT="Process $pid is no longer available."
    return 1
  fi

  APP_INSPECT_TOP_CONTENT=""
  APP_INSPECT_TOP_NEXT_AT=0
  APP_INSPECT_CONTENT="$(app_compose_inspect_content "" "loading")"

  app_start_inspect_top_refresh || true
  return 0
}

app_start_inspect_top_refresh() {
  if [ -z "$APP_INSPECT_PID" ]; then
    return 1
  fi

  if [ -n "$APP_INSPECT_TOP_JOB_PID" ] && kill -0 "$APP_INSPECT_TOP_JOB_PID" >/dev/null 2>&1; then
    return 0
  fi

  if [ -n "$APP_INSPECT_TOP_JOB_FILE" ] && [ -f "$APP_INSPECT_TOP_JOB_FILE" ]; then
    rm -f "$APP_INSPECT_TOP_JOB_FILE" >/dev/null 2>&1 || true
  fi

  APP_INSPECT_TOP_JOB_FILE="$(mktemp "${TMPDIR:-/tmp}/gatan-top.${APP_INSPECT_PID}.XXXXXX")" || return 1

  (
    actions_get_live_metrics_snapshot "$APP_INSPECT_PID" >"$APP_INSPECT_TOP_JOB_FILE" 2>/dev/null \
      || printf '%s\n' "(metrics unavailable)" >"$APP_INSPECT_TOP_JOB_FILE"
  ) &
  APP_INSPECT_TOP_JOB_PID=$!

  return 0
}

app_poll_inspect_top_refresh() {
  local now_ms="${1:-}"

  if [ -z "$APP_INSPECT_TOP_JOB_PID" ]; then
    return 1
  fi

  if kill -0 "$APP_INSPECT_TOP_JOB_PID" >/dev/null 2>&1; then
    return 1
  fi

  wait "$APP_INSPECT_TOP_JOB_PID" >/dev/null 2>&1 || true
  APP_INSPECT_TOP_JOB_PID=""

  if [ -n "$APP_INSPECT_TOP_JOB_FILE" ] && [ -f "$APP_INSPECT_TOP_JOB_FILE" ]; then
    APP_INSPECT_TOP_CONTENT="$(cat "$APP_INSPECT_TOP_JOB_FILE" 2>/dev/null || true)"
    rm -f "$APP_INSPECT_TOP_JOB_FILE" >/dev/null 2>&1 || true
  fi
  APP_INSPECT_TOP_JOB_FILE=""

  if [ -n "$APP_INSPECT_TOP_CONTENT" ]; then
    APP_INSPECT_CONTENT="$(app_compose_inspect_content "$APP_INSPECT_TOP_CONTENT" "ready")"
  else
    APP_INSPECT_CONTENT="$(app_compose_inspect_content "" "unavailable")"
  fi

  if [ -z "$now_ms" ]; then
    now_ms="$(app_now_millis)"
  fi
  APP_INSPECT_TOP_NEXT_AT=$((now_ms + GATAN_METRICS_REFRESH_INTERVAL_MS))
  app_mark_redraw
  return 0
}

app_tick_inspect_top() {
  local now_ms="${1:-}"

  if [ "$APP_VIEW" != "inspect" ] || [ -z "$APP_INSPECT_PID" ]; then
    return 1
  fi

  if [ -z "$now_ms" ]; then
    now_ms="$(app_now_millis)"
  fi

  app_poll_inspect_top_refresh "$now_ms" || true

  if [ -n "$APP_INSPECT_TOP_JOB_PID" ]; then
    return 0
  fi

  if [ "$APP_INSPECT_TOP_NEXT_AT" -gt "$now_ms" ]; then
    return 0
  fi

  app_start_inspect_top_refresh || true
  APP_INSPECT_TOP_NEXT_AT=$((now_ms + GATAN_METRICS_REFRESH_INTERVAL_MS))
  return 0
}

app_validate_sudo() {
  if sudo -n true >/dev/null 2>&1; then
    return 0
  fi

  if [ "${GATAN_TEST_DISABLE_UI:-0}" != "1" ]; then
    if ! ui_prompt_sudo_explainer "$GATAN_SUDO_PROMPT"; then
      ui_restore_terminal
      printf 'Cancelled sudo authentication.\n' >&2
      return 1
    fi

    # Restore terminal mode so sudo can read the password prompt normally.
    ui_restore_terminal
    if ! sudo -v -p "$GATAN_SUDO_PROMPT"; then
      printf 'Failed to authenticate with sudo.\n' >&2
      return 1
    fi

    ui_init_terminal
    ui_force_full_redraw
    return 0
  fi

  if ! sudo -v >/dev/null 2>&1; then
    printf 'Failed to authenticate with sudo.\n' >&2
    return 1
  fi

  return 0
}

app_kill_pid() {
  local pid="$1"
  local command="$2"

  if ! ui_prompt_yes_no "Terminate PID $pid ($command)? [y/N] "; then
    app_set_status "Cancelled termination for PID $pid."
    return 0
  fi

  if ! actions_send_signal TERM "$pid"; then
    app_set_status "Failed to send SIGTERM to PID $pid."
    return 1
  fi

  if actions_wait_for_exit "$pid"; then
    app_set_status "Sent SIGTERM to PID $pid."
    return 0
  fi

  if ! ui_prompt_yes_no "PID $pid still running. Force SIGKILL? [y/N] "; then
    app_set_status "PID $pid is still running."
    return 0
  fi

  if ! actions_send_signal KILL "$pid"; then
    app_set_status "Failed to send SIGKILL to PID $pid."
    return 1
  fi

  if actions_wait_for_exit "$pid" 5 "$GATAN_TERM_WAIT_INTERVAL"; then
    app_set_status "Sent SIGKILL to PID $pid."
    return 0
  fi

  app_set_status "SIGKILL sent but PID $pid still appears alive."
  return 1
}

app_handle_main_key() {
  local key="$1"
  local pid
  local command

  case "$key" in
    UP)
      if [ "$APP_SELECTED_INDEX" -gt 0 ]; then
        APP_SELECTED_INDEX=$((APP_SELECTED_INDEX - 1))
        app_mark_redraw
      fi
      ;;
    DOWN)
      if [ "$APP_SELECTED_INDEX" -lt $((${#APP_ROWS[@]} - 1)) ]; then
        APP_SELECTED_INDEX=$((APP_SELECTED_INDEX + 1))
        app_mark_redraw
      fi
      ;;
    ENTER)
      if [ "${#APP_ROWS[@]}" -eq 0 ]; then
        return 0
      fi

      pid="$(app_selected_pid || true)"
      command="$(app_selected_command || true)"
      if [ -z "$pid" ]; then
        app_set_status "No process selected."
        return 0
      fi

      APP_INSPECT_PID="$pid"
      APP_INSPECT_COMMAND="$command"
      app_load_inspect "$pid" || app_set_status "Process $pid is unavailable."
      APP_VIEW="inspect"
      ui_force_full_redraw
      app_mark_redraw
      ;;
    K)
      if [ "${#APP_ROWS[@]}" -eq 0 ]; then
        app_set_status "No process selected."
        return 0
      fi

      pid="$(app_selected_pid || true)"
      command="$(app_selected_command || true)"
      if [ -n "$pid" ]; then
        app_kill_pid "$pid" "$command" || true
        app_request_main_refresh 0
      fi
      ;;
    R)
      app_set_status "Refreshing listener list..."
      app_request_main_refresh 1
      ;;
    Q)
      APP_RUNNING=0
      ;;
  esac
}

app_handle_inspect_key() {
  local key="$1"

  case "$key" in
    B)
      app_stop_inspect_top_refresh
      APP_VIEW="main"
      ui_force_full_redraw
      app_request_main_refresh 0
      app_mark_redraw
      ;;
    K)
      if [ -n "$APP_INSPECT_PID" ]; then
        app_kill_pid "$APP_INSPECT_PID" "$APP_INSPECT_COMMAND" || true
        app_request_main_refresh 0

        if actions_pid_exists "$APP_INSPECT_PID"; then
          app_load_inspect "$APP_INSPECT_PID" || true
        else
          app_stop_inspect_top_refresh
          APP_VIEW="main"
          ui_force_full_redraw
        fi
        app_mark_redraw
      fi
      ;;
    R)
      if [ -n "$APP_INSPECT_PID" ]; then
        ui_force_full_redraw
        app_load_inspect "$APP_INSPECT_PID" || app_set_status "Process $APP_INSPECT_PID is unavailable."
        app_mark_redraw
      fi
      ;;
    Q)
      APP_RUNNING=0
      ;;
  esac
}

app_run() {
  local key
  local now_ms
  local has_epochrealtime=0

  core_require_dependencies || return 1

  if [ "${GATAN_TEST_DISABLE_UI:-0}" != "1" ]; then
    ui_init_terminal
  fi

  app_validate_sudo || return 1
  app_start_sudo_keepalive
  app_refresh_rows || true
  now_ms="$(app_now_millis)"
  if [ -n "${EPOCHREALTIME:-}" ]; then
    has_epochrealtime=1
  fi
  APP_MAIN_REFRESH_NEXT_AT=$((now_ms + GATAN_MAIN_REFRESH_INTERVAL_MS))

  if [ "${GATAN_TEST_DISABLE_UI:-0}" = "1" ]; then
    return 0
  fi

  ui_force_full_redraw
  app_set_status "Loaded ${#APP_ROWS[@]} listening services."
  app_mark_redraw

  while [ "$APP_RUNNING" -eq 1 ]; do
    if [ "$has_epochrealtime" -eq 1 ]; then
      now_ms="$(app_now_millis)"
    else
      now_ms=$((now_ms + GATAN_INPUT_POLL_INTERVAL_MS))
    fi

    if app_expire_status_if_needed "$now_ms"; then
      app_mark_redraw
    fi
    app_tick_main_refresh "$now_ms" || true
    app_tick_inspect_top "$now_ms" || true

    if [ "$APP_NEEDS_REDRAW" -eq 1 ]; then
      app_adjust_scroll

      if [ "$APP_VIEW" = "main" ]; then
        ui_render_main "$APP_SELECTED_INDEX" "$APP_SCROLL_INDEX" "$(app_get_status_message)"
      else
        ui_render_inspect "$APP_INSPECT_PID" "$APP_INSPECT_COMMAND" "$(app_get_status_message)"
      fi

      APP_NEEDS_REDRAW=0
    fi

    key="$(ui_read_key "$GATAN_INPUT_POLL_INTERVAL_SECONDS" || true)"
    if [ -z "$key" ]; then
      continue
    fi

    if [ "$APP_VIEW" = "main" ]; then
      app_handle_main_key "$key"
    else
      app_handle_inspect_key "$key"
    fi
  done

  return 0
}

main() {
  if [ "$#" -gt 1 ]; then
    printf 'Too many arguments. Try: gatan --help\n' >&2
    return 1
  fi

  case "${1:-}" in
    "") ;;
    --help | -h)
      app_print_help
      return 0
      ;;
    --version | -v)
      gatan_version
      return 0
      ;;
    *)
      printf 'Unknown option: %s\n' "$1" >&2
      printf 'Try: gatan --help\n' >&2
      return 1
      ;;
  esac

  app_run
}

if [ "${BASH_SOURCE[0]}" = "$0" ]; then
  trap app_cleanup EXIT INT TERM
  trap 'ui_force_full_redraw; APP_NEEDS_REDRAW=1' WINCH
  main "$@"
fi
